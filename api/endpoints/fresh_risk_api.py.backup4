from fastapi import APIRouter, HTTPException
from typing import Dict, Any, List, Union
import logging
import time

logger = logging.getLogger(__name__)

# Create router
router = APIRouter(prefix="/api/risk", tags=["risk"])

# Import risk service and models
try:
    from services.risk_service_updated import RiskAnalysisService
    risk_service = RiskAnalysisService()
    SERVICE_AVAILABLE = True
    logger.info("✅ Risk service initialized successfully")
except Exception as e:
    logger.error(f"❌ Risk service not available: {e}")
    risk_service = None
    SERVICE_AVAILABLE = False

# Import centralized models if available
try:
    from models.requests import RiskAnalysisRequest
    CENTRALIZED_MODELS = True
except ImportError:
    CENTRALIZED_MODELS = False

@router.get("/health")
async def risk_health():
    """Risk service health check"""
    return {
        "service": "risk_analysis", 
        "status": "healthy" if SERVICE_AVAILABLE else "degraded",
        "centralized_models": CENTRALIZED_MODELS,
        "timestamp": time.time()
    }

@router.post("/analyze")
async def analyze_risk(request_data: Dict[str, Any]):
    """Risk analysis endpoint with safe attribute handling"""
    
    if not SERVICE_AVAILABLE or not risk_service:
        raise HTTPException(status_code=503, detail="Risk service not available")
    
    try:
        # Handle both centralized models and raw dictionaries
        if CENTRALIZED_MODELS:
            try:
                # Try to parse with centralized model
                parsed_request = RiskAnalysisRequest(**request_data)
                
                # Extract values safely - check what attributes exist
                symbols = parsed_request.symbols if hasattr(parsed_request, 'symbols') else []
                period = getattr(parsed_request, 'period', '1year')
                use_real_data = getattr(parsed_request, 'use_real_data', True)
                confidence_level = getattr(parsed_request, 'confidence_level', 0.95)
                
                # Handle period enum vs string
                if hasattr(period, 'value'):
                    period = period.value
                
                # Try different attribute names for analysis_type
                analysis_type = None
                for attr_name in ['analysis_type', 'risk_analysis_type', 'type', 'analysis_mode']:
                    if hasattr(parsed_request, attr_name):
                        analysis_type = getattr(parsed_request, attr_name)
                        if hasattr(analysis_type, 'value'):
                            analysis_type = analysis_type.value
                        break
                
                if analysis_type is None:
                    analysis_type = 'comprehensive'  # Default
                
                logger.info(f"Using centralized models: symbols={len(symbols)}, period={period}, type={analysis_type}")
                
            except Exception as e:
                logger.warning(f"Centralized model parsing failed: {e}, falling back to raw dict")
                # Fall back to raw dictionary
                symbols = request_data.get("symbols", [])
                period = request_data.get("period", "1year")
                analysis_type = request_data.get("analysis_type", "comprehensive")
                confidence_level = request_data.get("confidence_level", 0.95)
                use_real_data = request_data.get("use_real_data", True)
        else:
            # Raw dictionary handling
            symbols = request_data.get("symbols", [])
            period = request_data.get("period", "1year")
            analysis_type = request_data.get("analysis_type", "comprehensive")  
            confidence_level = request_data.get("confidence_level", 0.95)
            use_real_data = request_data.get("use_real_data", True)
        
        # Call the service with extracted parameters
        result = risk_service.comprehensive_risk_analysis(
            symbols=symbols,
            period=period,
            analysis_type=analysis_type,
            confidence_level=confidence_level,
            use_real_data=use_real_data
        )
        
        return result
        
    except Exception as e:
        logger.error(f"Risk analysis failed: {e}", exc_info=True)
        raise HTTPException(
            status_code=500,
            detail=f"Risk analysis failed: {str(e)}"
        )

# Compatibility
app = router
